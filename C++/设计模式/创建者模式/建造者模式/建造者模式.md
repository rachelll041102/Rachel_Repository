# 建造者模式

## 概述 
将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。
+ 分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。
+ 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。
+ 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。
  
  
简而言之，就是把创建和组装进行分离,工厂模式

## 结构
1. 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。
2. 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。
3. 产品类（Product）：要创建的复杂对象。
4. 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。

## 例子
共享单车类：Director负责组装，builder负责创建  
组装单车的过程:
1. Director选择指定的builder,
2. builder有各个零件frame，seat的创建流程
3. Director调用builder的零件创建，并进行组装
```

                            Director                 director需要传入指定的builder类    
                                |                    Director类里面有包装类，负责调用builder类的各个创建零件的函数并让builder返回bike  
                                |  
                        -----builder-----  
                        |      (抽象类)  |  
                        |               |  
                    ofoBuilder      MoBikeBuilder       builder类里面有分别创建单车的frame函数，seat函数  
                        |               |               还有一个返回bike的函数  
                        |               |  
                        --------bike-----  
                                |  
                                |  
                        private:frame,seat  
```
## 优缺点
+ 优点：
1. 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封在指挥者类中对整体而言可以取得比较好的稳定性。
2. 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
3. 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
4.  建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。
+ 缺点：
造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。