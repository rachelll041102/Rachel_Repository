## 软件设计原则


* 开闭原则  
    + **对扩展开放，对修改关闭**。  
    + 在程序需要进行拓展的时候，**不能**去修改原有的代码，只能进行拓展  
    + 目的是为了使程序的扩展性好，易于维护和升级。  
  
* 里氏替换原则  
    + 任何基类可以出现的地方，子类一定可以出现。  
    + 通俗理解：子类可以扩展父类的功能，但**不能**改变父类原有的功能。  
    + 换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。  
      
* 依赖倒转原则  
    + 高层模块不应该依赖低层模块，两者都应该依赖其抽象。  
    ```例子：  
        一台计算机 需要cpu，硬盘，内存条
        此时计算机应该连接他们的抽象类，而不是连接他们的实例类
        这样就可以做到变更零件，只需要重写另一个实例就行了
    ```  

* 接口隔离原则  
    + 客户端不应该被迫依赖于它不使用的方法；  
    + 一个类对另一个类的依赖应该建立在最小的接口上。

* 迪米特法则
    + 只和你的直接朋友交谈，不跟“陌生人”说话  
    + **如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。**    
    + 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
    + 类似中介

* 合成复用原则
    + 尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。  
    + 通常类的复用分为继承复用和合成复用两种。继承复用虽然有简单和易实现的优点，但它也存在以下缺点：    
        1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。   
        2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。    
        3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。  
    + 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：  
        1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。  
        2. 对象间的耦合度低。可以在类的成员位置声明抽象。  
        3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。  
